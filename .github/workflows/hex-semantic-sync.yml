The failure in your workflow is due to an authorization issue with the `TOKEN` being used. Specifically, the error message indicates that the action is not authorized to perform the requested operation.

### Solution
1. **Verify the Secret Token**: Ensure that the secret `HEXSYNCFRESH` is correctly set in your repository settings.
    - Go to your repository on GitHub.
    - Navigate to **Settings** > **Secrets and variables** > **Actions**.
    - Ensure that `HEXSYNCFRESH` is listed and has the correct value.

2. **Check Token Permissions**: Verify that the token has the necessary permissions to perform the action.
    - The token should have write access to the API endpoint you're trying to reach.

3. **Update Workflow to Log More Information**: Modify the workflow to provide more detailed logging.

Here is an updated version of your workflow file to include additional logging:

```yaml
name: Hex Semantic Model Ingest

on:
  push:
    branches:
      - main

env:
  TOKEN: ${{ secrets.HEXSYNCFRESH }}
  DIRECTORY: .

jobs:
  hex-semantic-model-ingest:
    runs-on: ubuntu-latest
    steps:
    - name: Verify token
      run: |
        if [ -z "$TOKEN" ]; then
          echo "❌ Error: TOKEN not found. Please make sure the secret referenced in your workflow file exists in your repository."
          exit 1
        else
          echo "✅ Token exists, proceeding..."
        fi

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Zip semantic model
      run: |
        cd $DIRECTORY
        zip -r repo.zip .

    - name: Ingest Semantic Model to Hex
      run: |
        response=$(curl -s -w "%{http_code}" -o response.txt -X POST \
          -F "data=@$DIRECTORY/repo.zip" \
          https://app.hex.tech/api/v1/semantic-models/0195f2b6-396e-7007-8d12-43fd068c1bbb/ingest \
          -H "Authorization: Bearer $TOKEN")
        http_code=$(tail -n1 response.txt)
        if [ "$http_code" -eq 201 ]; then
          echo "✅ Successfully ingested semantic model:"
          cat response.txt | jq
        else
          echo "❌ Something went wrong:"
          echo "HTTP Status Code: $http_code"
          cat response.txt
          exit 1
        fi
```

This updated workflow includes more detailed logging for the HTTP status code, which can help in debugging the issue further.
